// Generated by CoffeeScript 1.9.2
/*! Shapelydee 0.0.5 //// MIT Licence //// http://shapelydee.loop.coop/ */
(function(global) {

/* Define the Oopish container. 
Rather than just a generic object, the Oopish container can also be used as 
a handy shortcut for console.log(). Note bind() (http://goo.gl/66ffgl), and 
unusual IE8-9 behaviour (http://goo.gl/ZmG9Xs). */
var oo = (function (c) { return (
(!c || !c.log) // IE8-9 without F12 dev-tools, IE6-7, FF1-3.6
? function () {}
: ("object" === typeof c.log) // IE8-9 with F12 dev-tools
? function () { c.log([].slice.call(arguments).join(" ")) }
: (! Function.prototype.bind) // OP10.6-11.5, SF4-5.0, iOS3-5.1, ADRD2.1-3.0?
? function () { c.log.apply(c, arguments) }
: c.log.bind(c)
)}(global.console));

/* Define constants generated by oopish-build and injected into app-scope. */
oo.G = global // global scope, passed into the closure as an argument
oo.T = "Shapelydee" // project title, from package.json
oo.V = "0.0.5" // project version, from package.json


/*! Shapelydee 0.0.5 */
var Pixel, Shape, ShapelyDee, Tudor, tudor, x, xx,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

oo.A = 'array';

oo.B = 'boolean';

oo.D = 'document';

oo.E = 'error';

oo.F = 'function';

oo.I = 'integer';

oo.N = 'number';

oo.O = 'object';

oo.R = 'regexp';

oo.S = 'string';

oo.U = 'undefined';

oo.X = 'null';

oo._ = (Math.random().toString(36) + '00000000').substr(2, 8);

oo.ROBUSTABLE = (function() {
  if (!Object.preventExtensions) {
    return false;
  } else if (Object.defineProperty) {
    try {
      Object.defineProperty({}, 'x', {});
      return true;
    } catch (_error) {
      return false;
    }
  } else {
    return true;
  }
})();

oo.is = function(c, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (c) {
    return t;
  } else {
    return f;
  }
};

oo.isU = function(x) {
  return oo.U === typeof x;
};

oo.isX = function(x) {
  return null === x;
};

oo.type = function(a) {
  var ta;
  if (oo.isX(a)) {
    return oo.X;
  }
  ta = typeof a;
  if ({
    undefined: 1,
    string: 1,
    number: 1,
    boolean: 1
  }[ta]) {
    return ta;
  }
  if (!a.nodeName && a.constructor !== Array && /function/i.test('' + a)) {
    return oo.F;
  }
  return {}.toString.call(a).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
};

oo.ex = function(x, a, b) {
  var pos;
  if (-1 === (pos = a.indexOf(x))) {
    return x;
  } else {
    return b.charAt(pos);
  }
};

oo.has = function(h, n, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (-1 !== h.indexOf(n)) {
    return t;
  } else {
    return f;
  }
};

oo.uid = function(p) {
  if (p == null) {
    p = 'id';
  }
  return p + '_' + (Math.random().toString(36) + '00000000').substr(2, 8);
};

oo.uid62 = function(p, l) {
  var c;
  if (p == null) {
    p = 'id';
  }
  if (l == null) {
    l = 8;
  }
  c = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  return p + '_' + ((function() {
    var results;
    results = [];
    while (l--) {
      results.push(c.charAt(Math.floor(Math.random() * 62)));
    }
    return results;
  })()).join('');
};

oo.pad = oo.lpad = function(s, l, c) {
  if (c == null) {
    c = ' ';
  }
  return s + Array(l - s.length + 1).join(c);
};

oo.rpad = function(s, l, c) {
  if (c == null) {
    c = ' ';
  }
  return Array(l - s.length + 1).join(c) + s;
};

oo.insert = function(basis, overlay, offset) {
  return basis.slice(0, offset) + overlay + basis.slice(offset + overlay.length);
};

if (oo.ROBUSTABLE) {
  oo.define = function(obj, name, value, kind) {
    switch (kind) {
      case 'constant':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: true
        });
      case 'private':
        return Object.defineProperty(obj, name, {
          value: value,
          enumerable: false
        });
    }
  };
} else {
  oo.define = function(obj, name, value, kind) {
    return obj[name] = value;
  };
}

if (oo.ROBUSTABLE) {
  oo.lock = function(obj) {
    var j, key, len, ref;
    ref = Object.keys(obj);
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      Object.defineProperty(obj, key, {
        writable: false,
        configurable: false
      });
    }
    Object.preventExtensions(obj);
    if (obj.prototype && obj !== obj.prototype) {
      return oo.lock(obj.prototype);
    }
  };
} else {
  oo.lock = function() {};
}

oo.vArray = function(M, arr, signature, fallback) {
  var i, j, k, len, len1, limit, matches, max, min, pass, ref, ref1, ref2, rule, tv, type, types, value;
  matches = signature.match(/^<\[([|a-z]+)\s*(.*)\](\d+-\d+)?>$/i);
  if (!matches) {
    throw RangeError("/shapelydee/oopish/oo-helpers.litcoffee oo.vArray()\n  signature " + signature + " is invalid");
  }
  signature = matches[0], types = matches[1], rule = matches[2], limit = matches[3];
  if (!arr) {
    return fallback;
  }
  if (oo.A !== oo.type(arr)) {
    throw RangeError(M + (" is type " + (oo.type(arr)) + " not array"));
  }
  if (limit) {
    ref = limit.split('-'), min = ref[0], max = ref[1];
    if (arr.length < min || arr.length > max) {
      throw RangeError(M + (".length is " + arr.length + " (must be " + limit + ")"));
    }
  }
  if ('any' === types) {
    return arr;
  }
  for (i = j = 0, len = arr.length; j < len; i = ++j) {
    value = arr[i];
    tv = oo.type(value);
    pass = false;
    ref1 = types.split('|');
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      type = ref1[k];
      if ((oo.N === type || oo.I === type) && oo.N === tv) {
        if (oo.I === type && value % 1) {
          throw RangeError(M + ("[" + i + "] is a number but not an integer"));
        }
        if (rule) {
          ref2 = rule.split('-'), min = ref2[0], max = ref2[1];
          if (value < min || value > max) {
            throw RangeError(M + ("[" + i + "] is " + value + " (must be " + rule + ")"));
          }
        }
        pass = true;
        break;
      }
      if (type === tv) {
        if (oo.S === tv && rule) {
          if (!RegExp(rule).test(value)) {
            throw RangeError(M + ("[" + i + "] fails " + rule));
          }
        }
        pass = true;
        break;
      }
      if (/^[A-Z]/.test(type)) {
        if (oo.O === tv) {
          if (eval("value instanceof " + type)) {
            pass = true;
            break;
          }
        }
      }
    }
    if (pass) {
      continue;
    }
    throw TypeError(M + ("[" + i + "] is type " + tv + " not " + types));
  }
  return arr;
};

oo.vArg = function(M, value, signature, fallback) {
  var j, key, len, matches, max, min, pfx, ref, ref1, rule, tv, type, types;
  matches = signature.match(/^([_a-z][_a-z0-9]*)\s+<([|a-z]+)\s*(.*)>$/i);
  if (!matches) {
    throw RangeError("/shapelydee/oopish/oo-helpers.litcoffee oo.vArg()\n  signature " + signature + " is invalid");
  }
  signature = matches[0], key = matches[1], types = matches[2], rule = matches[3];
  pfx = M + ("argument " + key + " ");
  tv = oo.type(value);
  if (oo.U === tv) {
    if (4 === arguments.length) {
      return fallback;
    }
    throw TypeError(pfx + "is undefined and has no fallback");
  }
  ref = types.split('|');
  for (j = 0, len = ref.length; j < len; j++) {
    type = ref[j];
    if ((oo.N === type || oo.I === type) && oo.N === tv) {
      if (oo.I === type && value % 1) {
        throw RangeError(pfx + "is a number but not an integer");
      }
      if (rule) {
        ref1 = rule.split('-'), min = ref1[0], max = ref1[1];
        if (value < min || value > max) {
          throw RangeError(pfx + ("is " + value + " (must be " + rule + ")"));
        }
      }
      return value;
    }
    if (type === tv) {
      if (oo.S === tv && rule) {
        if (!RegExp(rule).test(value)) {
          throw RangeError(pfx + ("fails " + rule));
        }
      }
      return value;
    }
    if (/^[A-Z]/.test(type)) {
      if (oo.O === tv) {
        if (eval("value instanceof " + type)) {
          return value;
        }
      }
    }
  }
  throw TypeError(pfx + ("is type " + tv + " not " + types));
};

oo.vObject = function(M, objName, obj) {
  if (oo.O !== oo.type(obj)) {
    throw TypeError(M + objName + (" is type " + (oo.type(obj)) + " not object"));
  }
  return function(signature, fallback) {
    var j, key, len, matches, max, min, ref, ref1, rule, tv, type, types, value;
    matches = signature.match(/^([_a-z][_a-z0-9]*)\s+<([|a-z]+)\s*(.*)>$/i);
    if (!matches) {
      throw RangeError("/shapelydee/oopish/oo-helpers.litcoffee oo.vObject()\n  signature " + signature + " is invalid");
    }
    signature = matches[0], key = matches[1], types = matches[2], rule = matches[3];
    value = obj[key];
    tv = oo.type(value);
    if (oo.U === tv) {
      if (2 === arguments.length) {
        return fallback;
      }
      throw TypeError(M + objName + '.' + key + " is undefined and has no fallback");
    }
    ref = types.split('|');
    for (j = 0, len = ref.length; j < len; j++) {
      type = ref[j];
      if ((oo.N === type || oo.I === type) && oo.N === tv) {
        if (oo.I === type && value % 1) {
          throw RangeError(M + objName + '.' + key + " is a number but not an integer");
        }
        if (rule) {
          ref1 = rule.split('-'), min = ref1[0], max = ref1[1];
          if (value < min || value > max) {
            throw RangeError(M + objName + '.' + key + (" is " + value + " (must be " + rule + ")"));
          }
        }
        return value;
      }
      if (type === tv) {
        if (oo.S === tv && rule) {
          if (!RegExp(rule).test(value)) {
            throw RangeError(M + objName + '.' + key + (" fails " + rule));
          }
        }
        return value;
      }
      if (/^[A-Z]/.test(type)) {
        if (oo.O === tv) {
          if (eval("value instanceof " + type)) {
            return value;
          }
        }
      }
    }
    throw TypeError(M + objName + '.' + key + (" is type " + tv + " not " + types));
  };
};

Pixel = (function() {
  Pixel.prototype.C = 'Pixel';

  Pixel.prototype.toString = function() {
    return '[object Pixel]';
  };

  function Pixel(config) {
    var M, v;
    if (config == null) {
      config = {};
    }
    M = '/shapelydee/src/Pixel.litcoffee Pixel()\n  ';
    v = oo.vObject(M, 'config', config);
    this.id = 'p' + config.id;
    this.origin = config.origin;
    oo.define(this, oo._, {}, 'private');
    this[oo._]._x = null;
    if ('Pixel' === this.C) {
      oo.lock(this);
    }
  }

  Pixel.prototype.xx = function(yy) {
    var M;
    M = '/shapelydee/src/Pixel.litcoffee Pixel::xx()\n  ';
    return yy = oo.vArg(M, yy, 'yy <number>', 123);
  };

  return Pixel;

})();

Pixel.xx = function(yy) {
  var M;
  M = '/shapelydee/src/Pixel.litcoffee Pixel.xx()\n  ';
  return yy = oo.vArg(M, yy, 'yy <number>', 123);
};

Shape = (function() {
  Shape.prototype.C = 'Shape';

  Shape.prototype.toString = function() {
    return '[object Shape]';
  };

  function Shape(config) {
    var M, v;
    if (config == null) {
      config = {};
    }
    M = '/shapelydee/src/Shape.litcoffee Shape()\n  ';
    v = oo.vObject(M, 'config', config);
    this.id = 's' + config.id;
    this.origin = config.origin;
    this.scale = config.scale;
    this.rotation = config.rotation;
    this.color = config.color;
    this.blend = config.blend;
    oo.define(this, oo._, {}, 'private');
    this[oo._]._x = null;
    if ('Shape' === this.C) {
      oo.lock(this);
    }
  }

  Shape.prototype.renderId = function(out) {
    var M, l;
    M = '/shapelydee/src/Shape.litcoffee Shape::renderId()\n  ';
    l = this.id.length;
    out[this.origin[1] + 10][this.origin[0] + 10].c = this.id.charAt(0);
    if (out[this.origin[1] + 10][this.origin[0] + 10 + 1]) {
      out[this.origin[1] + 10][this.origin[0] + 10 + 1].c = this.id.charAt(1);
    }
    if (2 < l && out[this.origin[1] + 10][this.origin[0] + 10 + 2]) {
      out[this.origin[1] + 10][this.origin[0] + 10 + 2].c = this.id.charAt(2);
    }
    if (3 < l && out[this.origin[1] + 10][this.origin[0] + 10 + 3]) {
      out[this.origin[1] + 10][this.origin[0] + 10 + 3].c = this.id.charAt(3);
    }
    return out;
  };

  return Shape;

})();

Shape.xx = function(yy) {
  var M;
  M = '/shapelydee/src/Shape.litcoffee Shape.xx()\n  ';
  return yy = oo.vArg(M, yy, 'yy <number>', 123);
};

ShapelyDee = (function() {
  ShapelyDee.prototype.C = 'ShapelyDee';

  ShapelyDee.prototype.toString = function() {
    return '[object ShapelyDee]';
  };

  function ShapelyDee(config) {
    var M, i, px, v;
    if (config == null) {
      config = {};
    }
    M = '/shapelydee/src/ShapelyDee.litcoffee ShapelyDee()\n  ';
    v = oo.vObject(M, 'config', config);
    this.x = v('x <number>', 123);
    oo.define(this, oo._, {}, 'private');
    this[oo._]._shapes = [];
    this[oo._]._pixels = [];
    px = config.pixelCoords || [];
    i = 0;
    while (!oo.isU(px[i])) {
      this[oo._]._pixels.push(new Pixel({
        id: this[oo._]._pixels.length,
        origin: [px[i++], px[i++], px[i++]]
      }));
    }
    if ('ShapelyDee' === this.C) {
      oo.lock(this);
    }
  }

  ShapelyDee.prototype.add = function(config) {
    var M, a, blend, color, origin, rotation, scale, v;
    M = '/shapelydee/src/ShapelyDee.litcoffee ShapelyDee::add()\n  ';
    v = oo.vObject(M, 'config', config);
    a = v('a <string ^pixel|cube$>');
    origin = config.origin;
    scale = config.scale;
    rotation = config.rotation;
    color = config.color;
    blend = config.blend;
    if ('pixel' === a) {
      return this[oo._]._pixels.push(new Pixel({
        id: this[oo._]._pixels.length,
        origin: origin
      }));
    }
    if ('cube' === a) {
      return this[oo._]._shapes.push(new Shape.Cube({
        id: this[oo._]._shapes.length,
        origin: origin,
        scale: scale,
        rotation: rotation,
        color: color,
        blend: blend
      }));
    }
  };

  ShapelyDee.prototype.dump = function(format) {
    var M, aa, ab, ac, i, j, k, len, len1, len2, len3, loc, m, o, out, pixel, q, ref, ref1, ref2, row, shape, table, u, x, y, z;
    M = '/shapelydee/src/ShapelyDee.litcoffee ShapelyDee::dump()\n  ';
    format = oo.vArg(M, format, 'format <string ^ascii|html|led$>', 'led');
    if ('ascii' || 'html' === format) {
      out = [];
      for (y = j = 0; j <= 20; y = ++j) {
        out[y] = [];
        for (x = k = 0; k <= 20; x = ++k) {
          out[y].push({
            c: 10 === x ? '|' : 10 === y ? '-' : '·',
            r: 0,
            g: 0,
            b: 0
          });
        }
      }
      ref = this[oo._]._shapes;
      for (i = m = 0, len = ref.length; m < len; i = ++m) {
        shape = ref[i];
        out = shape.renderSilhouette(out);
      }
      ref1 = this[oo._]._shapes;
      for (i = o = 0, len1 = ref1.length; o < len1; i = ++o) {
        shape = ref1[i];
        out = shape.renderId(out);
      }
      table = [];
      ref2 = this[oo._]._pixels;
      for (i = q = 0, len2 = ref2.length; q < len2; i = ++q) {
        pixel = ref2[i];
        loc = out[pixel.origin[1] + 10][pixel.origin[0] + 10];
        loc.c = '*';
        table.push({
          id: pixel.id,
          r: loc.r + '',
          g: loc.g + '',
          b: loc.b + ''
        });
      }
      if ('html' === format) {
        for (y = u = 0; u <= 20; y = ++u) {
          row = '<div>';
          for (x = z = 0; z <= 20; x = ++z) {
            loc = out[y][x];
            row += '*' === loc.c ? '<i ' : '<b ';
            row += "style='background:rgb(" + loc.r + "," + loc.g + "," + loc.b + ")'>" + loc.c;
            row += '*' === loc.c ? '</i>' : '</b>';
          }
          out[y] = row + '</div>';
        }
      } else {
        for (y = aa = 0; aa <= 20; y = ++aa) {
          row = '';
          for (x = ab = 0; ab <= 20; x = ++ab) {
            row += out[y][x].c;
          }
          out[y] = row;
        }
      }
      for (i = ac = 0, len3 = table.length; ac < len3; i = ++ac) {
        row = table[i];
        out.push("" + (oo.pad(row.id, 4)) + (oo.rpad(row.r, 4)) + (oo.rpad(row.g, 4)) + (oo.rpad(row.b, 4)));
      }
      return out.join('\n');
    }
    if ('led' === format) {
      return [10, 20, 30];
    }
  };

  return ShapelyDee;

})();

ShapelyDee.xx = function(yy) {
  var M;
  M = '/shapelydee/src/ShapelyDee.litcoffee ShapelyDee.xx()\n  ';
  return yy = oo.vArg(M, yy, 'yy <number>', 123);
};

x = null;

xx = function(yy) {
  var M;
  return M = '/shapelydee/src/ShapelyDee.litcoffee xx()\n  ';
};

Shape.Cube = (function(superClass) {
  extend(Cube, superClass);

  Cube.prototype.C = 'Shape.Cube';

  Cube.prototype.toString = function() {
    return '[object Shape.Cube]';
  };

  function Cube(config) {
    var M, v;
    if (config == null) {
      config = {};
    }
    M = '/shapelydee/src/Shape/Cube.litcoffee Shape.Cube()\n  ';
    Cube.__super__.constructor.call(this, config);
    v = oo.vObject(M, 'config', config);
    this.id = 'c' + config.id;
    this[oo._]._x = null;
    if ('Shape.Cube' === this.C) {
      oo.lock(this);
    }
  }

  Cube.prototype.renderSilhouette = function(out) {
    var M, b, c, h, j, k, l, r, ref, ref1, ref2, ref3, t, w, y;
    M = '/shapelydee/src/Shape.litcoffee Shape::renderSilhouette()\n  ';
    w = this.scale[0];
    h = this.scale[1];
    l = Math.max(0, this.origin[0] - (Math.floor(w / 2)) + 10);
    r = Math.min(20, this.origin[0] + (Math.ceil(w / 2)) + 10);
    t = Math.max(0, this.origin[1] - (Math.floor(h / 2)) + 10);
    b = Math.min(20, this.origin[1] + (Math.ceil(h / 2)) + 10);
    for (y = j = ref = t, ref1 = b; ref <= ref1 ? j <= ref1 : j >= ref1; y = ref <= ref1 ? ++j : --j) {
      for (x = k = ref2 = l, ref3 = r; ref2 <= ref3 ? k <= ref3 : k >= ref3; x = ref2 <= ref3 ? ++k : --k) {
        c = out[y][x].c;
        out[y][x].c = '=' === c || '#' === c ? '#' : '=';
        out[y][x].r = Math.min(255, out[y][x].r + this.color[0]);
        out[y][x].g = Math.min(255, out[y][x].g + this.color[1]);
        out[y][x].b = Math.min(255, out[y][x].b + this.color[2]);
      }
    }
    return out;
  };

  return Cube;

})(Shape);

Shape.Cube.xx = function(yy) {
  var M;
  M = '/shapelydee/src/Shape/Cube.litcoffee Shape.Cube.xx()\n  ';
  return yy = oo.vArg(M, yy, 'yy <number>', 123);
};

Tudor = (function() {
  Tudor.prototype.I = 'Tudor';

  Tudor.prototype.toString = function() {
    return "[object " + I + "]";
  };

  Tudor.prototype.articles = [];

  function Tudor(opt) {
    this.opt = opt != null ? opt : {};
    this["do"] = bind(this["do"], this);
    switch (this.opt.format) {
      case 'html':
        this.pageHead = function(summary) {
          return "<style>\n  body     { font-family: sans-serif; }\n  a        { outline: 0; }\n  b        { display: inline-block; width: .7em }\n\n  b.pass              { color: #393 }\n  b.fail              { color: #bbb }\n  article.fail b.pass { color: #bbb }\n  section.fail b.pass { color: #bbb }\n\n  pre      { padding: .5em; margin: .2em 0; border-radius: 4px; }\n  pre.fn   { background-color: #fde }\n  pre.pass { background-color: #cfc }\n  pre.fail { background-color: #d8e0e8 }\n\n  article  { margin-bottom: .5rem }\n  article h2 { padding-left:.5rem; margin:0; font-weight:normal }\n  article.pass { border-left: 5px solid #9c9 }\n  article.fail { border-left: 5px solid #9bf }\n  article.fail h2 { margin-bottom: .5rem }\n  article.pass >div { display: none }\n\n  section  { margin-bottom: .5rem }\n  section h3   { padding-left: .5rem; margin: 0; }\n  section.pass { border-left: 3px solid #9c9 }\n  section.fail { border-left: 3px solid #9bf }\n  section.fail h3 { margin-bottom: .5rem }\n  section.pass >div { display: none }\n\n  article.fail section.pass { border-left-color: #ccc }\n\n  div      { padding-left: .5em; }\n  div.fail { border-left: 3px solid #9bf; font-size: .8rem }\n  div h4   { margin: 0 }\n  div h4 { font: normal .8rem/1.2rem monaco, monospace }\n  div.fail, div.fail h4 { margin: .5rem 0 }\n\n</style>\n<h4><a href=\"#end\" id=\"top\">\u2b07</a>  " + summary + "</h4>";
        };
        this.pageFoot = function(summary) {
          return "<h4><a href=\"#top\" id=\"end\">\u2b06</a>  " + summary + "</h4>\n<script>\n  document.title='" + (summary.replace(/<\/?[^>]+>/g, '')) + "';\n</script>";
        };
        this.articleHead = function(heading, fail) {
          return ("<article class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h2>" + (fail ? this.cross : this.tick) + heading + "</h2><div>");
        };
        this.articleFoot = '</div></article>';
        this.sectionHead = function(heading, fail) {
          return ("<section class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h3>" + (fail ? this.cross : this.tick) + heading + "</h3><div>");
        };
        this.sectionFoot = '</div></section>';
        this.jobFormat = function(heading, result) {
          return ("<div class=\"" + (result ? 'fail' : 'pass') + "\">") + ("<h4>" + (result ? this.cross : this.tick) + heading + "</h4>") + ("" + (result ? this.formatError(result) : '')) + "</div>";
        };
        this.tick = '<b class="pass">\u2713</b> ';
        this.cross = '<b class="fail">\u2718</b> ';
        break;
      default:
        this.pageHead = function(summary) {
          return "" + summary;
        };
        this.pageFoot = function(summary) {
          return "\n" + summary;
        };
        this.articleHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n===" + (new Array(heading.length).join('=')) + "\n";
        };
        this.articleFoot = '';
        this.sectionHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n---" + (new Array(heading.length).join('-')) + "\n";
        };
        this.sectionFoot = '';
        this.jobFormat = function(heading, result) {
          return ((result ? this.cross : this.tick) + " " + heading) + ("" + (result ? '\n' + this.formatError(result) : ''));
        };
        this.jobFoot = '';
        this.tick = '\u2713';
        this.cross = '\u2718';
    }
  }

  Tudor.prototype.add = function(lines) {
    var article, i, line, runner, section;
    article = {
      sections: []
    };
    runner = null;
    section = null;
    if (oo.A !== oo.type(lines)) {
      throw Error("`lines` isn’t an array");
    }
    if (0 === lines.length) {
      throw Error("`lines` has no elements");
    }
    if (oo.S !== oo.type(lines[0])) {
      throw Error("`lines[0]` isn’t a string");
    }
    article.heading = lines.shift();
    i = 0;
    while (i < lines.length) {
      line = lines[i];
      switch (oo.type(line)) {
        case oo.O:
          if (!line.runner) {
            throw new Error("Errant object");
          }
          runner = line.runner;
          break;
        case oo.F:
          section.jobs.push(line);
          break;
        case oo.S:
          if (this.isAssertion(lines[i + 1], lines[i + 2])) {
            if (!section) {
              throw new Error("Cannot add an assertion here");
            }
            section.jobs.push([runner, line, lines[++i], lines[++i]]);
          } else {
            section = {
              heading: line,
              jobs: []
            };
            article.sections.push(section);
          }
      }
      i++;
    }
    return this.articles.push(article);
  };

  Tudor.prototype["do"] = function() {
    var actual, art, artFail, artPass, article, e, error, expect, heading, j, job, k, len, len1, len2, m, mock, mockFail, pge, pgeFail, pgePass, ref, ref1, ref2, result, runner, sec, secFail, secPass, section, summary;
    pge = [];
    mock = [];
    pgePass = pgeFail = mockFail = 0;
    ref = this.articles;
    for (j = 0, len = ref.length; j < len; j++) {
      article = ref[j];
      art = [];
      artPass = artFail = 0;
      ref1 = article.sections;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        section = ref1[k];
        sec = [];
        secPass = secFail = 0;
        ref2 = section.jobs;
        for (m = 0, len2 = ref2.length; m < len2; m++) {
          job = ref2[m];
          switch (oo.type(job)) {
            case oo.F:
              try {
                mock = job.apply(this, mock);
              } catch (_error) {
                e = _error;
                error = e.message;
              }
              if (error) {
                mockFail++;
                secFail++;
                sec.push(this.formatMockModifierError(job, error));
              }
              break;
            case oo.A:
              runner = job[0], heading = job[1], expect = job[2], actual = job[3];
              result = runner(expect, actual, mock);
              if (!result) {
                sec.push(this.jobFormat("" + (this.sanitize(heading))));
                pgePass++;
                artPass++;
                secPass++;
              } else {
                sec.push(this.jobFormat("" + (this.sanitize(heading)), result));
                pgeFail++;
                artFail++;
                secFail++;
              }
          }
        }
        sec.unshift(this.sectionHead("" + (this.sanitize(section.heading)), secFail));
        sec.push(this.sectionFoot);
        art = art.concat(sec);
      }
      art.unshift(this.articleHead("" + (this.sanitize(article.heading)), artFail));
      art.push(this.articleFoot);
      pge = pge.concat(art);
      summary = pgeFail ? this.cross + " FAILED " + pgeFail + "/" + (pgePass + pgeFail) : this.tick + " Passed " + pgePass + "/" + (pgePass + pgeFail);
      if (mockFail) {
        summary = "\n" + this.cross + " (MOCK FAILS)";
      }
    }
    pge.unshift(this.pageHead(summary));
    pge.push(this.pageFoot(summary));
    return pge.join('\n');
  };

  Tudor.prototype.formatError = function(result) {
    switch (result.length + "-" + this.opt.format) {
      case '2-html':
        return result[0] + "\n<pre class=\"fail\">" + (this.sanitize(result[1].message)) + "</pre>";
      case '2-plain':
        return result[0] + "\n" + (this.sanitize(result[1].message));
      case '3-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + "</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + "</pre>";
      case '3-plain':
        return (this.sanitize(this.reveal(result[0]))) + "\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2])));
      case '4-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + " (" + (oo.type(result[0])) + ")</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + " (" + (oo.type(result[2])) + ")</pre>";
      case '4-plain':
        return (this.sanitize(this.reveal(result[0]))) + " (" + (oo.type(result[0])) + ")\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2]))) + " (" + (oo.type(result[2])) + ")";
      default:
        throw new Error("Cannot process '" + result.length + "-" + this.opt.format + "'");
    }
  };

  Tudor.prototype.formatMockModifierError = function(fn, error) {
    switch (this.opt.format) {
      case 'html':
        return "<pre class=\"fn\">" + (this.sanitize(fn + '')) + "</pre>\n...encountered an exception:\n<pre class=\"fail\">" + (this.sanitize(error)) + "</pre>";
      default:
        return (this.sanitize(fn + '')) + "\n...encountered an exception:\n" + (this.sanitize(error));
    }
  };

  Tudor.prototype.reveal = function(value) {
    return value != null ? value.toString().replace(/^\s+|\s+$/g, function(match) {
      return '\u00b7' + (new Array(match.length)).join('\u00b7');
    }) : void 0;
  };

  Tudor.prototype.sanitize = function(value) {
    switch (this.opt.format) {
      case 'html':
        return value != null ? value.toString().replace(/</g, '&lt;') : void 0;
      default:
        return value;
    }
  };

  Tudor.prototype["throw"] = {
    runner: function(expect, actual, mock) {
      var e, error;
      if (mock == null) {
        mock = [];
      }
      error = false;
      try {
        actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (!error) {
        return [
          'No exception thrown, expected', {
            message: expect
          }
        ];
      } else if (expect !== error.message) {
        return [error.message, 'was thrown, but expected', expect];
      }
    }
  };

  Tudor.prototype.equal = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      if (mock == null) {
        mock = [];
      }
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== result) {
        if (result + '' === expect + '') {
          return [result, 'was returned, but expected', expect, true];
        } else {
          return [result, 'was returned, but expected', expect];
        }
      }
    }
  };

  Tudor.prototype.is = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      if (mock == null) {
        mock = [];
      }
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== oo.type(result)) {
        return ["type " + (oo.type(result)), 'was returned, but expected', "type " + expect];
      }
    }
  };

  Tudor.prototype.match = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      if (mock == null) {
        mock = [];
      }
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (oo.F !== typeof expect.test) {
        return [
          '`test()` is not a function', {
            message: expect
          }
        ];
      } else if (!expect.test('' + result)) {
        return ['' + result, 'failed test', expect];
      }
    }
  };

  Tudor.prototype.isAssertion = function(line1, line2) {
    if (oo.F !== oo.type(line2)) {
      return false;
    }
    if ((oo.O === oo.type(line1)) && oo.F === oo.type(line1.runner)) {
      return false;
    }
    return true;
  };

  return Tudor;

})();

tudor = new Tudor({
  format: oo.O === typeof window ? 'html' : 'plain'
});

ShapelyDee.runTest = tudor["do"];

tudor.add([
  "01 ShapelyDee Constructor", tudor.is, "The class and instance are expected types", function() {
    return [new ShapelyDee];
  }, "The ShapelyDee class is a function", oo.F, function() {
    return ShapelyDee;
  }, "`new` returns an object", oo.O, function(shapelydee) {
    return shapelydee;
  }, tudor.equal, "`ShapelyDee::C` is 'ShapelyDee'", 'ShapelyDee', function(shapelydee) {
    return shapelydee.C;
  }, "`ShapelyDee::toString()` is '[object ShapelyDee]'", '[object ShapelyDee]', function(shapelydee) {
    return shapelydee + '';
  }, "Instance properties as expected", tudor.equal, "`ShapelyDee::x` is the number `123`", 123, function(shapelydee) {
    return shapelydee.x;
  }, "`ShapelyDee::_shapes` is private, and is an array", 'array', function(shapelydee) {
    return oo.type(shapelydee[oo._]._shapes);
  }, "`ShapelyDee::_shapes` is an empty array", 0, function(shapelydee) {
    return shapelydee[oo._]._shapes.length;
  }, "`ShapelyDee::_pixels` is private, and is an array", 'array', function(shapelydee) {
    return oo.type(shapelydee[oo._]._pixels);
  }, "`ShapelyDee::_pixels` is an empty array", 0, function(shapelydee) {
    return shapelydee[oo._]._pixels.length;
  }, "config.pixelCoords usage", tudor.equal, "`config.pixelCoords` can be passed an empty array", 0, function() {
    return (new ShapelyDee({
      pixelCoords: []
    }))[oo._]._pixels.length;
  }, "`ShapelyDee::_pixels` contains one Pixel, if pixelCoords is 3 numbers", 1, function() {
    return (new ShapelyDee({
      pixelCoords: [0, 1, 2]
    }))[oo._]._pixels.length;
  }
]);

if (oo.ROBUSTABLE) {
  tudor.add([
    "91 Robust ShapelyDee Constructor (for modern UAs)", tudor.is, "Class members are immutable in modern UAs", function() {
      return [new ShapelyDee];
    }, "Cannot add a property to the ShapelyDee class", oo.U, function() {
      ShapelyDee.nope = 123;
      return ShapelyDee.nope;
    }, "Cannot add a property to the ShapelyDee class’s prototype object", oo.U, function(shapelydee) {
      ShapelyDee.prototype.nope = 456;
      return shapelydee.nope;
    }, tudor.equal, "`ShapelyDee::C` is a constant", 'ShapelyDee', function(shapelydee) {
      shapelydee.C = 'changed!';
      return shapelydee.C;
    }
  ]);
}

oo.lock(ShapelyDee);

oo.lock(Shape);

oo.lock(Shape.Cube);

oo.lock(Pixel);

if (oo.F === typeof define && define.amd) {
  define(function() {
    return ShapelyDee;
  });
} else if (oo.O === typeof module && module && module.exports) {
  module.exports = ShapelyDee;
} else {
  oo.G.ShapelyDee = ShapelyDee;
}
}).call(this,this);
// Example vendor file. 
